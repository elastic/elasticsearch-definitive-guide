
==== Contains, but does not equal

It is important to understand that `term` and `terms` are "contains" operations, 
not "equals".  What does that mean?

If you have a term filter for `{ "term" : { "tags" : "search" } }`, it will match 
_both_ of the following documents:

[source,js]
--------------------------------------------------
{ "tags" : ["search"] }
{ "tags" : ["search", "open source"] }
--------------------------------------------------

Recall how the `term` filter works: it checks the inverted index for all
documents which contain a term, then constructs a bitset.  This means that only
one of the values within a field has to match for a `1` bit to be set.
This makes `term` (and `terms` too) a "must contain" operation, not a "must equal
exactly" operation.

==== Equals exactly
If you do want that behavior -- entire field equality -- the best way to 
accomplish it involves indexing a secondary field.  In this field, you index the
number of values that your field contains.  Using our two previous documents:

[source,js]
--------------------------------------------------
{ "tags" : ["search"], "tag_count" : 1 }
{ "tags" : ["search", "open source"], "tag_count" : 2 }
--------------------------------------------------

Once you have the count information indexed, you can construct a `bool` filter 
that enforces the appropriate number of terms:

[source,js]
--------------------------------------------------
GET /my_index/my_type/_search
{
    "filtered" : {
        "filter" : {
             "bool" : {
                "must" : [
                    { "term" : { "tags" : "search" } },
                    { "term" : { "tag_count" : 1 } }
                ]
            }
        }
    }
}
--------------------------------------------------


This query will now match only the document that has a single tag which is 
`search`, rather than any document which contains `search`.

.Why can't Elasticsearch do this automatically?
****
Due to the nature of an inverted index, operations like "only this term" are 
relatively expensive.  An inverted index looks up the term and finds a list of 
all documents that contain it.

Entire field equality, however, inverts the requirement.  You need to look up a
document and determine what words are in each field.  This is very expensive to
do in an inverted index.  An inverted index is not optimized for that type of
data access.  It is far more efficient to just index the number of
terms so that you can check manually.
****