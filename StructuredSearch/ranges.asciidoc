
Filtering on ranges is a very common structured search. Elasticsearch allows
filtering on both numeric and string-based ranges.  The `range` filter is what 
you'll use most often use to work with ranges.  It automatically detects
the type you are working with (numeric or string) and applies the correct 
algorithm.

Why would there be different algorithms?  Essentially, numeric values can be
ranged much more efficiently than strings.

==== Numeric ranges

TODO: Verify this with Simon
TODO: image to display this

Say you want to find all documents where `age` is between 20 and 30.  Internally,
the numeric values are represented by a sorted prefix tree.  Briefly, a prefix
tree is a tree structure where nodes represent prefixes of the final children.

See Figure TODO for a graphical depiction of a prefix tree.

As Elasticsearch traverses the tree, nodes which do not share the range's prefix 
can be avoided entirely, meaning large parts of the tree never need to be 
evaluated.

This leads to very fast operation.  Due to the nature of sorted trees, you can 
find the min/max with few operations.

==== String Ranges
String ranges are done in lexicographical order: "a" comes before "ab", which 
are sorted before "ac", etc.

In contrast to numeric ranges, there are no tricks that can be performed
to enhance speed. A prefix tree cannot be maintained for string fields, since 
it is a very purpose-built data structure.

We can afford to build a prefix tree for numeric values because the number of
operations are very limited (for example, you never need to do phrase matching,
or fuzzy, or wildcard, etc).  Numeric fields just need to provide search for
exact matches and ranges, nothing more.

In contrast, strings need to support the full range of full-text operations, so
our only option is to evaluate the inverted index item-by-item.

1. *Skip to near the starting range*
+
Using a special data structure, Elasticsearch can skip to near the starting 
value of the range, avoiding a large amount of unnecessary comparison.

2. *Collect all terms in the range*
+
Once we have skipped near the start of the range, there is nothing else we can
do but iterate over the terms in the inverted index, collecting document IDs
until we hit the end of the range.

As you can see, unlike numeric ranges (which can find the min/max in only a few
operations), a lexicographical range will always require as many operations as
it takes to traverse all the terms in the range.  If there are 1000
terms that fall in the range...Elasticsearch has to make a minimum of 1000
comparisons.

This isn't to say avoid ranges on strings -- they are still quite fast.
And like most filters, ranges are cached so subsequent executions are even faster.
However, it is good to be aware how ranges are executed so you can make intelligent
design choices for both data architecture and queries.

.Watch out for analyzers!
****
If you are filtering string ranges, make sure the analyzer is configured
appropriately.  Often, it is a good idea to set a field `not_analyzed`, or at
least lowercased, so that fields are ordered appropriately.

If a field is analyzed into multiple tokens, you may get strange results 
matching your range filter and not understand why.
****
