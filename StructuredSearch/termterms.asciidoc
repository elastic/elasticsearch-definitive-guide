When working with exact matches (and especially `not_analyzed` fields), the
filters you will use most often are the Term and Terms filter.

Analysis happens not only while indexing a document, but also while parsing
your search query.  The Match query, for example, will split your search query
into tokens and perform whatever extra analysis is required (lowercasing, stemming, etc).

This is obviously bad if you are looking for exact matches.  You need your search text
to be untouched so that it can find the exact string in the index.

This is what the Term/Terms filters are designed for.  They perform no analysis step --
they search for the exact string that you specify.

==== Term Filter (singular)

Imagine we have these three documents indexed (and the title field is `not_analyzed`):

[source,js]
--------------------------------------------------
 { "title" : "Twelfth Night" }
 { "title" : "TWELFTH NIGHT" }
 { "title" : "twelfth night" }
 { "title" : "twelfth" }
--------------------------------------------------


If you used a Match query to search for "Twelfth Night":

[source,js]
--------------------------------------------------
 {
     "query" : {
         "match" : {
             "title" : "Twelfth Night"
         }
     }
 }
--------------------------------------------------


...then all four documents would be returned (even the one that is only a partial match).
Match query is analyzing your text, which means it will be lowercased, tokenized and match all
four docs.  Instead, if you use a Term filter (placed inside of a filtered query):

[source,js]
--------------------------------------------------
 {
     "query" : {
         "filtered_query" : {
             "query" : { "match_all" : {} },
             "filter" : {
                 "term" : {
                     "title" : "Twelfth Night"
                 }
             }
         }
     }
 }
--------------------------------------------------


Then only the first document will be returned, because it is the only doc that exactly matches your
query text.

==== Terms Filter (plural)

The Terms filter is just a plural version of the singular Term filter.  Instead of looking for
a single term, it will look for two or more terms:

[source,js]
--------------------------------------------------
 {
     "query" : {
         "filtered_query" : {
             "query" : { "match_all" : {} },
             "filter" : {
                 "terms" : {
                     "title" : ["Twelfth Night", "twelfth night"]
                 }
             }
         }
     }
 }
--------------------------------------------------


This query will return the first and third document.  The Terms filter is an OR operation.
Only one of the provided terms needs to be present in a document for it to match the filter.

==== Term/Terms Query?

You might have noticed that there are also query versions of Term/Terms. How are these different?
Should you use them?

The key difference is that they are queries, and thus affect scoring.  For example, the Terms
filter from above can be reformulated as a query:

[source,js]
--------------------------------------------------
 {
     "query" : {
         "terms" : {
             "title" : ["Twelfth Night", "twelfth night"]
         }
     }
 }
--------------------------------------------------


The Query version will
 a. match any document that has at least one of the terms
 b. add a boost to the score for each term that matches

Phrased another way, the Terms Query rewards documents that have more matching terms by
boosting their score, while the Terms filter simply looks for the presence of at least one term.

In practice, look at your query and decide if the presence/absence of a term should affect
the score.  If it does, use a query.  If not, use a filter for performance reasons.

.Does Term/Terms only work with not_analyzed fields?
****
Nope! Although Term/Terms is _usually_ used in combination with a `not_analyzed` field,
it isn't required.  Term/Terms simply ignores the analysis phase at query-time.

For example, imagine the default analyzer for this index lowercases all fields.  If you index
this document, the title field will be lowercased:

[source,js]
--------------------------------------------------
 { "title" : "MACBETH" }
--------------------------------------------------


You can then search for it with a Term Filter, appropriately lowercased:

[source,js]
--------------------------------------------------
 {
     "query" : {
         "filtered_query" : {
             "query" : { "match_all" : {} },
             "filter" : {
                 "term" : {
                     "title" : "macbeth"
                 }
             }
         }
     }
 }
--------------------------------------------------


And you will get the document back because the title field was lowercased before it was indexed.
****