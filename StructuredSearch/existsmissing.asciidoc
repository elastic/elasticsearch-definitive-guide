
Due to the dynamic nature of Elasticsearch, it is common to insert documents
into an index without knowing _a priori_ what fields are in the document.  This
is a huge benefit for building robust applications, but it does introduce some
interesting dilemmas.

Consider our last example, where documents have a field named `tags`.  This is
a multi-valued field.  A document may have one tag, many tags, or potentially
no tags at all.

How is this data represented in the inverted index?  If you think back to when
we introduced the inverted index, it stores a list of terms for a particular
field. For each term in that list, it also stores the list of documents which
contain the term.

If a field is empty (e.g. there are no `tags` for a document), there are no
terms to index, which means there will be no information added to the inverted
index.  Ultimately, this means that a `null`, `[]` (an empty array), and `[null]`
are all equivalent...they simply don't exist in the inverted index!

Obviously the world is not simple, and data is often missing fields, contains
explicit nulls or empty arrays. To deal with these situations, Elasticsearch has
a few tools to work with null or missing values.

==== Exists Filter

The first tool in your arsenal is the `exists` filter.  This filter will return
documents that have values in the specified field. Let's use the tagging example.
First, we need to create an index and make sure the `tags` field is `not_analyzed`
to avoid analysis problems.  Then we can insert some data:

[source,js]
--------------------------------------------------
PUT /my_index <1>
{
    "mappings" : {
        "posts" : {
            "properties" : {
                "tags" : {
                    "type" : "string",
                    "index" : "not_analyzed"
                }
            }
        }
    }
}

POST /my_index/posts/_bulk
{ "index": { "_id": "1" }}
{"tags" : ["search"] }
{ "index": { "_id": "2" }}
{ "tags" : ["search", "open source"] }
{ "index": { "_id": "3" }}
{ "other_field" : "some data" }
{ "index": { "_id": "4" }}
{ "tags" : null }
{ "index": { "_id": "5" }}
{ "tags" : ["search", null] }

--------------------------------------------------
<1> Like we saw earlier in <<_term_filter_with_text>>, we need to explicitly
make these fields `not_analyzed` so that a default analyzer is not applied

This data contains a variety of documents.  The first two documents have normal,
multi-valued data.  Document `3` has no tags at all, while doc `4` explicitly
sets `null` for the `tags` field.  Finally, document `5` has one "real" tag
and one explicit null.

Our objective is to find all documents where a tag is set.  We don't care what
the tag is, so long as it exists within the document.  To answer this question,
we use the exists filter:

[source,js]
--------------------------------------------------
GET /my_index/posts/_search
{
    "query" : {
        "filtered" : {
            "filter" : {
                "exists" : {"field" : "tags"}
            }
        }
    }
}
--------------------------------------------------

Our query returns three documents:

[source,json]
--------------------------------------------------
"hits" : [
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "1",
      "_score" : 1.0, "_source" : {"tags" : ["search"] }
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "5",
      "_score" : 1.0, "_source" : { "tags" : ["search", null] } <1>
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "2",
      "_score" : 1.0, "_source" : { "tags" : ["search", "open source"] }
    }
]
--------------------------------------------------
<1> Notice how doc `5` is returned, even though we indexed a `null` value. The
field exists because a "normal" tag was indexed, so the `null` had no impact
on the filter.

The results are easy to understand.  Any document that has actual terms in the
`tags` field was returned as a hit.  The only two documents that were excluded
were document `3` and `4`:

[source,js]
--------------------------------------------------
// Document #3
{ "other_field" : "some data" }
--------------------------------------------------

Document `3` didn't specify the `tags` field at all, so it isn't surprising that
it doesn't match the `exists` filter.

[source,js]
--------------------------------------------------
// Document #4
{ "tags" : null }
--------------------------------------------------

Document `4` did specify the `tags` field, but it passed an explicit `null`.
To Elasticsearch, an explicit `null` is the same a field not existing at all.
Internally, nothing was indexed for that field...it is functionally equivalent
to document `3`.

==== Missing Filter

The Missing filter is essentially the inverse of the Exists filter: it returns
documents where there is _no_ value for a particular field.  Let's swap the
`exists` filter for a `missing` filter in our example above:

[source,js]
--------------------------------------------------
GET /my_index/posts/_search
{
    "query" : {
        "filtered" : {
            "missing" : {"field" : "tags"}
        }
    }
}
--------------------------------------------------

And, as you would expect, we get the inverse search results back (doc `3` and
`4`):

[source,json]
--------------------------------------------------
"hits" : [
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "3",
      "_score" : 1.0, "_source" : { "other_field" : "some data" }
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "4",
      "_score" : 1.0, "_source" : { "tags" : null }
    }
]
--------------------------------------------------




==== Exists/Missing on Objects

The Exists and Missing filters also work on objects, not just core types.  If
you have the following document:

[source,js]
--------------------------------------------------
{
   "foo" : {
      "bar" : "baz"
   }
}
--------------------------------------------------


You can check for the existence of "foo".  If the inner object "foo" exists,
Existing filter matches while Missing does not.

Internally, the filter is looking at all fields that match `foo.*` and evaluating
if they have values or not.  TODO: Clint halp!


