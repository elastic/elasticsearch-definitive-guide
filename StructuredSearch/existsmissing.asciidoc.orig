

Think back to our last example, where documents have a field named `tags`.  This is
a multi-valued field.  A document may have one tag, many tags, or potentially
<<<<<<< HEAD
no tags at all.

How is this data represented in the inverted index?  If you think back to when
we introduced the inverted index, it stores a list of terms for a particular
field. For each term in that list, it also stores the list of documents which
contain the term.

If a field is empty (e.g. there are no `tags` for a document), there are no
terms to index, which means there will be no information added to the inverted
index.  Ultimately, this means that a `null`, `[]` (an empty array), and `[null]`
=======
no tags at all. If a field is not specified at all, how is it stored in an 
inverted index?

That's a trick question, because the answer is "it isn't stored at all". Let's
look at that inverted index from last section:

[width="50%",frame="topbot"]
|==========================
| Token | DocIDs
|`search`| `1`,`2`
|`open_source` | `2`
|==========================

How would you store a field that doesn't exist in that data structure?  You 
can't!  An inverted index is simply a list of tokens and the documents that
contain them.  If a field doesn't exist...it doesn't hold any tokens, which
means it won't be represented in an inverted index data structure.

Ultimately, this means that a `null`, `[]` (an empty array), and `[null]`
>>>>>>> editing
are all equivalent...they simply don't exist in the inverted index!

Obviously the world is not simple, and data is often missing fields, contains
explicit nulls or empty arrays. To deal with these situations, Elasticsearch has
a few tools to work with null or missing values.

==== Exists Filter

<<<<<<< HEAD
The first tool in your arsenal is the `exists` filter.  This filter will return
documents that have values in the specified field. Let's use the tagging example.
=======
The first tool in your arsenal is the `exists` filter.  This filter will return 
documents that have any value in the specified field. Let's use the tagging example.
>>>>>>> editing
First, we need to create an index and make sure the `tags` field is `not_analyzed`
to avoid analysis problems.  Then we can insert some data:

[source,js]
--------------------------------------------------
PUT /my_index <1>
{
    "mappings" : {
        "posts" : {
            "properties" : {
                "tags" : {
                    "type" : "string",
                    "index" : "not_analyzed"
                }
            }
        }
    }
}

POST /my_index/posts/_bulk
{ "index": { "_id": "1"              }}
{ "tags" : ["search"]                }
{ "index": { "_id": "2"              }}
{ "tags" : ["search", "open_source"] }
{ "index": { "_id": "3"              }}
{ "other_field" : "some data"        }
{ "index": { "_id": "4"              }}
{ "tags" : null                      }
{ "index": { "_id": "5"              }}
{ "tags" : ["search", null]          }

--------------------------------------------------
<1> Like we saw earlier in <<_term_filter_with_text>>, we need to explicitly
make these fields `not_analyzed` so that a default analyzer is not applied

This data contains a variety of documents.  The first two documents have normal,
multi-valued data.  Document `3` has no tags at all, while doc `4` explicitly
sets `null` for the `tags` field.  Finally, document `5` has one "real" tag
and one explicit null.  The resulting inverted index for our `tags` field
will look like this:

[width="50%",frame="topbot"]
|==========================
| Token | DocIDs
|`search`| `1`,`2`,`5`
|`open_source` | `2`
|==========================

Our objective is to find all documents where a tag is set.  We don't care what
<<<<<<< HEAD
the tag is, so long as it exists within the document.  To answer this question,
we use the exists filter:
=======
the tag is, so long as it exists within the document.  In SQL parlance,
we would use an `IS NOT NULL` query:

[source,SQL]
--------------------------------------------------
SELECT tags
FROM posts
WHERE tags IS NOT NULL
--------------------------------------------------

In Elasticsearch, we use the exists filter:
>>>>>>> editing

[source,js]
--------------------------------------------------
GET /my_index/posts/_search
{
    "query" : {
        "filtered" : {
            "filter" : {
                "exists" : {"field" : "tags"}
            }
        }
    }
}
--------------------------------------------------

Our query returns three documents:

[source,json]
--------------------------------------------------
"hits" : [
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "1",
      "_score" : 1.0, "_source" : {"tags" : ["search"] }
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "5",
      "_score" : 1.0, "_source" : { "tags" : ["search", null] } <1>
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "2",
      "_score" : 1.0, "_source" : { "tags" : ["search", "open source"] }
    }
]
--------------------------------------------------
<1> Notice how doc `5` is returned, even though we indexed a `null` value. The
field exists because a "normal" tag was indexed, so the `null` had no impact
on the filter.

The results are easy to understand.  Any document that has actual terms in the
`tags` field was returned as a hit.  The only two documents that were excluded
were document `3` and `4`:

[source,js]
--------------------------------------------------
// Document #3
{ "other_field" : "some data" }
--------------------------------------------------

Document `3` didn't specify the `tags` field at all, so it isn't surprising that
it doesn't match the `exists` filter.

[source,js]
--------------------------------------------------
// Document #4
{ "tags" : null }
--------------------------------------------------

Document `4` did specify the `tags` field, but it passed an explicit `null`.
To Elasticsearch, an explicit `null` is the same a field not existing at all.
Internally, nothing was indexed for that field...it is functionally equivalent
to document `3`.

==== Missing Filter

The Missing filter is essentially the inverse of the Exists filter: it returns
<<<<<<< HEAD
documents where there is _no_ value for a particular field.  Let's swap the
`exists` filter for a `missing` filter in our example above:
=======
documents where there is _no_ value for a particular field.  Unsurprisingly, 
the SQL is an inverse from before too:

[source,SQL]
--------------------------------------------------
SELECT tags
FROM posts
WHERE tags IS  NULL
--------------------------------------------------

Let's swap the `exists` filter for a `missing` filter from our example above:
>>>>>>> editing

[source,js]
--------------------------------------------------
GET /my_index/posts/_search
{
    "query" : {
        "filtered" : {
            "missing" : {"field" : "tags"}
        }
    }
}
--------------------------------------------------

And, as you would expect, we get the inverse search results back (doc `3` and
`4`):

[source,json]
--------------------------------------------------
"hits" : [
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "3",
      "_score" : 1.0, "_source" : { "other_field" : "some data" }
    },
    {
      "_index" : "my_index",
      "_type" : "posts",
      "_id" : "4",
      "_score" : 1.0, "_source" : { "tags" : null }
    }
]
--------------------------------------------------




==== Exists/Missing on Objects

The Exists and Missing filters also work on objects, not just core types.  If
you have the following document:

[source,js]
--------------------------------------------------
{
   "name" : {
      "first" : "foo",
      "last" : "bar"
   }
}
--------------------------------------------------


You can check for the existence of `"name"`.  If the inner object `"name"` exists,
Existing filter matches while Missing does not.

<<<<<<< HEAD
Internally, the filter is looking at all fields that match `foo.*` and evaluating
if they have values or not.  TODO: Clint halp!
=======
To understand how this actually works, you need to realize that `"name"` is not
really represented as an object internally.  It is merely a namespace, and 
the namespace is "flattened" in the inverted index.

The field `"first"` is actually stored in the inverted index as `"name.first"`,
and `"last"` is stored as `"name.last"`.

When you perform an `exists` or `missing` on the object, you are effectively
asking "Are there any terms with in the `name` namespace?".  In more technical
terms, the following query:

[source,js]
--------------------------------------------------
{
    "exists" : {"field" : "name"}
}
--------------------------------------------------

Is really translated to this internally:

[source,js]
--------------------------------------------------
{
    "exists" : {"field" : "name.*"}
}
--------------------------------------------------

>>>>>>> editing


