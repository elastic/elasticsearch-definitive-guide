[[query-string-query]]
=== Query string mini-language

The `query_string` query is similar in kind to the
<<match-query,`match` query>>. Where it differs is in how it treats its
query string. For the `match` family of queries, the query string is
just text.  The `query_string` query, on the other hand, treats the query string
as a ``mini-language'', which can be used to describe complex queries
succinctly.

For instance, this query string:

[source,js]
--------------------------------------------------
 quic* brawn~ +fox status:active +author:"Joe Bloggs"
 AND date:[2012/01/01 TO *]
--------------------------------------------------


is translated into a compound query in which:

* a word beginning with `quic` should be present in the ``default field''
* a word similar to `brawn` should be present in the ``default field''
* the word `fox` must be present in the ``default field''
* the `status` field should contain the word `active`
* the `author` field must contain the phrase `"joe bloggs"`
* the `date` field must be a date from 2012 onwards

The full syntax for this mini-language is explained in the
{ref}/query-dsl-query-string-query.html#query-string-syntax[Query String Syntax]
reference docs.

.Danger, Will Robinson!
****
From the above, it should be obvious that, although these queries offer
a potentially powerful concise query syntax, they quickly become difficult
to read and debug.

The query string is first parsed as a mini-language --
a ``pre-tokenization'' step that can interfere with the analysis step,
producing unexpected results. Worse than that, incorrect formatting
of the query string will cause a syntax error, preventing the query from
running at all.

Exposing the `query_string` query to users can be risky -- it allows them
to search on any field in your index and to run slow, heavy queries which
might result in your nodes running out of memory and crashing.

*Note:* It is almost always better to use a <<match-query,`match` query>>
instead.

That said, the `query_string` query can be useful for trusted power users,
or for exposing only a few of the ``advanced'' features of the query syntax
by cleaning up the query string in your application before running the query.
****

==== `default_field`

In the query syntax, it is possible to target specific fields by specifying
the field name, followed by a colon. For instance:

[source,js]
--------------------------------------------------
 status:active  date:2012/01/01  title:(quick fox) lazy dog
--------------------------------------------------


However, the parts of the query for which no field name has been specified
(`lazy dog` in the above example), are matched against the `default_field`.
This defaults to the special <<all-field,`_all` field>>, which we will discuss
in <<mapping>>.

It is possible to specify a different `default_field` as follows:

[source,js]
--------------------------------------------------
 {
     "query_string" : {
         "query"         : "lazy dog",
         "default_field" : "content"
     }
 }
--------------------------------------------------


.`field` query
****
The `field` query is just another form of the `query_string` query, which
allows you to specify the `default_field` in a form more consistent with
the rest of the Query DSL. The above query is exactly equivalent to these
two queries:

[source,js]
--------------------------------------------------
 { "field" : { "content" : "lazy dog" }}
--------------------------------------------------


    {
      "field" : {
          "content" : {
              "query" : "lazy dog"
           }
       }
    }
****

==== `default_operator`

By default, each query term is optional. In other words, the query
string `"quick brown fox"` is interpreted as `"quick OR brown OR fox"`, where
the more terms that match, the more relevant.

This behaviour can be changed by changing the `default_operator` from
`OR` to `AND`:

[source,js]
--------------------------------------------------
 {
     "query_string" : {
         "query"            : "quick brown fox",
         "default_operator" : "AND"
     }
 }
--------------------------------------------------


==== `fields`

Like the <<multi-match-query,`multi_match` query>>, it is possible to run
the `query_string` query against multiple ``default'' fields, as follows:

[source,js]
--------------------------------------------------
 {
     "query_string" : {
         "query"  : "lazy dog",
         "fields" : [ "title", "content" ]
     }
 }
--------------------------------------------------


It also supports the same wildcard (`*`) field names and per-field
boosting (`^`) syntax as the `multi_match` query:

[source,js]
--------------------------------------------------
 {
     "query_string" : {
         "query"  : "lazy dog",
         "fields" : [ "title^2", "cont*" ]
     }
 }
--------------------------------------------------


By default, queries run on multiple fields are wrapped in a
<<bool-query,`bool` query>>. Like the `multi_match` query, you can choose
to use a <<dismax-query,`dis_max` query>> instead:

[source,js]
--------------------------------------------------
 {
     "query_string" : {
         "query"       : "lazy dog",
         "fields"      : [ "title^2", "cont*" ],
         "use_dis_max" : true,
         "tie_breaker" : 0.2
     }
 }
--------------------------------------------------


.Multi-field `multi_match` vs `query_string`
****
The `query_string` and `multi_match` queries rewrite multi-field queries in
quite different ways. While the `multi_match` query queries _each field
separately_, the `query_string` query treats all fields specified in
the `fields` parameter as a _single field_.

This `multi_match` query:

[source,js]
--------------------------------------------------
 {
     "multi_match": {
         "fields":  ["title", "content"},
         "query":   "foo bar",
         "operator: "and"
     }
 }
--------------------------------------------------


searches for documents where:

 * the `title` field contains `foo` and `bar`
 * OR
 * the `content` field contains `foo` and `bar`

while this `query_string` query:

[source,js]
--------------------------------------------------
 {
     "query_string": {
         "fields":           ["title", "content"},
         "query":            "foo bar",
         "default_operator:  "AND"
     }
 }
--------------------------------------------------


searches for documents where:

 * `foo` exists in either the `title` or `content` field
 * AND
 * `bar` exists in either the `title` or `content` field

****
