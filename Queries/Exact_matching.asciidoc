[[exact_queries]]
=== Querying exact values

To match against numeric, date, boolean or `not_analyzed`
string fields -- see <<analyzed_vs_not,`analyzed` vs `not_analyzed`>> below
-- we use the `match` query.

It does The Right Thing for each field based on its _mapping_ (or field
definition), which we will discuss in <<mapping>>:

* `not_analyzed` (enum) string fields

    { "match" : { "status" : "active" }}

* numbers

    { "match" : { "count" : 5 }}

* dates

    { "match" : { "created" : "2013/05/01" }}

* booleans

    { "match" : { "featured" : true }}


[[analyzed_vs_not]]
.`analyzed` vs `not_analyzed` string fields
****
String fields can contain either:

_Full text_::

like the body of an email, which should be _analyzed_ in order to be searchable.
The full text string `"The Quick Brown Fox!"` may, depending on the analyzer,
be indexed as the tokens: `["quick", "brown", "fox"]`.

_Exact values_::

like enums, post codes, product numbers, or tags, which are *not* analyzed
but are indexed exactly as they are, so the string `"Foxes Rule!"` would be
indexed as the single token `"Foxes Rule!"`.

By default, Elasticsearch assumes that all string fields contain
full text. They are defined (or ``mapped'') as:

    { "type": "string", "index": "analyzed" }

String fields which contain exact values have to be manually defined as:

    { "type": "string", "index": "not_analyzed" }

We will explain how to setup `not_analyzed` fields in <<mapping>>, but for
now, it is important to know the distinction between the two.
****

Normally, we would use filters for exact value matches as these clauses seldom
contribute to the relevance `_score`.  Instead, they typically function as
`yes|no` questions: ``is the `status` field `active`?'' or
``is the `published` date `2012/01/01`?''.

However, sometimes we *do* want them to contribute to relevance:

A user on a job website searches for the tags `html6`, `css3` and `jquery`.
We want at least one of these tags to match, but the more tags that match,
the better.

We could write this by combining three `match` clauses with a
<<bool_query,`bool` query>>:

    {
        "bool": {
            "should": [
                { "match": { "tag": "html6"  },
                { "match": { "tag": "css3"   },
                { "match": { "tag": "jquery" }
            ]
        }
    }

Also, because `html6` is such a rare tag, any job tagged with `html6` will
show up as being particularly relevant.

[NOTE]
====
Later, we will discuss the
<<custom_filters_score_query,`custom_filters_score` query>> which provides a
way to use filters to influence the relevance `_score` more efficiently.
====

