[[dsl]]
== Query DSL – powerful search language

elasticsearch provides an expressive, powerful query language called
the Query DSL (Domain Specific Language) which exposes much of the power
of Lucene through a simple JSON interface.

It is tuned for full text search, but is in no way limited just to that. It
also provides very fast and flexible filters, ranges, geo-location and more.

=== Queries vs Filters

There are two basic constructs available in the Query DSL:

* Filter
* Query

A _filter_ asks a `yes/no` question of every document:

* is the `created` date in the range `2011` .. `2012`?
* does the `tags` field contain the word `"foo"`?
* is the `geolocation` field within `10km` of a specified point?

A _query_ is like a filter, but also asks the question:
``How *well* does this document match?''

In other words, a query calculates how _relevant_ each document is and, by
default, sorts the results by the relevance score.
This concept of relevance is ideal for full text search, for which there is
seldom a completely ``correct'' answer.

For example, find documents:

* which best match the words: `full text search`
* which contain the word `run`, but include `runs` and `running`
* containing the words `quick`, `brown` and `fox` within
  10 words of each — the closer they are, the more relevant
* tagged as `lucene` or `search`, and consider documents with
  both tags to be more relevant than those with a single tag

Because queries are often associated with full text queries, many query clauses
have an analysis phase, where the full text query string is analyzed to
produce the terms or tokens that are stored in elasticsearch.

Filters are faster than queries because (a) they don't have to calculate
relevance, and (b) they are cacheable.

In summary, the general rule is: use queries for full text search or for
any condition that should affect the relevance score, and filters
for everything else.

=== Structure of a query

The search API requires a query. If none is specified, then it defaults to
a `match_all` query which, unsurprisingly, matches all documents.

==== A simple query

A simple `match` query clause which searches the `title` field for the words
`"search is cool"` would look like this:

    {
        "match":  { "title": "search is cool" }
    }

This query clause should be used as the value of the `query` parameter in the
search API:

    curl -XGET localhost:9200/_search -d '
    {
        "query": {
            "match":  { "title": "search is cool" }
        }
    }
    '

==== Filtering a query

To limit the results to only those documents whose `status` field is set to
the value `"active"`, you can combine your query clause with a filter clause
using a `filtered` query:

    {
        "filtered": {
            "query":    { "match": { "title":  "search is cool" }},
            "filter":   { "term":  { "status": "active" }}
        }
    }

The full request would look like this:

    curl -XGET localhost:9200/_search -d '
    {
        "query": {
            "filtered": {
                "query":    { "match": { "title":  "search is cool" }},
                "filter":   { "term":  { "status": "active" }}
            }
        }
    }
    '

==== A filter without a query

What if you wanted to apply just the `status is "active"` filter without any
associated query? The `query` parameter only accepts a query, so you need
to *wrap your filter in a query*.  One possibility is the `filtered` query
mentioned above:

    {
        "filtered": {
            "query":    { "match_all: {}},
            "filter":   { "term":  { "status": "active" }}
        }
    }

However, a more efficient query for this case is the `constant_score` query,
which skips the relevance scoring phase, and just returns a score of 1 for
every document:

    {
        "constant_score": {
            "filter":   { "term":  { "status": "active" }}
        }
    }

The full request would look like this:

    curl -XGET localhost:9200/_search -d '
    {
        "query":     {
            "constant_score": {
                "filter":   { "term":  { "status": "active" }}
            }
        }
    }
    '

[NOTE]
===============================
As will be explained in the rest of this chapter, query and filter clauses
are building blocks which can be combined and nested in complex and
interesting ways. However, the search API expects a *single* query clause to
be passed as the value of the `query` parameter.

We will not be repeating the full `curl` statement for every query clause,
as it should already be obvious from the above examples how to pass queries to
the search API.
===============================


=== Filters
* equality
* ranges
* Boolean and | or | not
* Null values exists | missing
* Other filters

=== Queries
==== Text queries vs Term queries
.


==== Match - the general purpose query
.


==== Other text queries
* query_string and field queries
* more_like_this
* fuzzy_like_this

==== Term queries
* term / terms
* range
* prefix
* fuzzy
* wildcard

==== Compound queries
* bool query
* dismax query
* boosting query

==== Other queries
.

==== Building a complex query
.


