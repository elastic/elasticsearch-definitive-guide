
=== Java Virtual Machine

You should always run the most recent version of the Java Virtual Machine (JVM),
unless otherwise stated on the Elasticsearch website.  Elasticsearch, and in
particular Lucene, is a very demanding piece of software.  The unit and integration
tests from Lucene often expose bugs in the JVM itself.  These bugs range from
mild annoyances to serious segfaults, so it is best to use the latest version
of the JVM where possible.

Java 7 is strongly preferred over Java 6.  Either Oracle or OpenJDK are acceptable
-- they are comparable in performance and stability.

If your application is written in Java and you are using the TransportClient
or NodeClient, make sure the JVM running your application is identical to the
server JVM.  There are a few locations in Elasticsearch where Java's native serialization
is used (IP addresses, exceptions, etc).  Unfortunately, Oracle has been known
change the serialization format between minor releases, leading to strange errors.
This happens rarely, but it is best practice to keep the JVM versions identical
between client and server.

.Please do not tweak JVM settings
****
The JVM exposes dozens (hundreds even!) of settings, parameters and configurations.
They allow you to tweak and tune almost every aspect of the JVM.

When a knob is encountered, it is human nature to want to turn it.  We implore
you to squash this desire and _not_ use custom JVM settings.  Elasticsearch is
a complex piece of software, and the current JVM settings have been tuned
over years of real-world usage.

It is easy to start turning knobs, producing opaque effects that are hard to measure,
and eventually detune your cluster into a slow, unstable mess.  When debugging
clusters, the first step is often to remove all custom configurations.  About
half the time this alone restores stability and performance.
****

=== Garbage Collector

As briefly introduces in <<garbage_collector_primer>>, the JVM uses a garbage
collector to free unused memory.  This tip is really an extension of the last tip,
but deserves it's own section for emphasis:

Do not change the default garbage collector!

The default GC for Elasticsearch is Concurrent-Mark and Sweep (CMS).  This GC
runs concurrently with the execution of the application so that it can minimize
pauses.  It does, however, have two stop-the-world phases.  It also has trouble
collecting large heaps.

Despite these downsides, it is currently the best GC for low-latency server software
like Elasticsearch.  The official recommendation is to use CMS.

There is a newer GC called the Garbage First GC (G1GC).  This newer GC is designed
to minimize pausing even more than CMS, and operate on large heaps.  It works
by dividing the heap into regions and predicting which regions contain the most
reclaimable space.  By collecting those regions first ("garbage first"), it can
minimize pauses and operate on very large heaps.

Sounds great!  Unfortunately, G1GC is still new and fresh bugs are found routinely.
These bugs are usually of the segfault variety, and will cause hard crashes.
The Lucene test suite is brutal on GC algorithms, and it seems that G1GC hasn't
had the kinks worked out yet.

We would like to recommend G1GC someday, but for now, it is simply not stable
enough to meet the demands of Elasticsearch and Lucene.

=== TransportClient vs NodeClient

If you are using Java, you may wonder when to use the TransportClient vs the
NodeClient.  As discussed at the beginning of the book, the TransportClient
acts as a communication layer between the cluster and your application.  It knows
the API and can automatically round-robin between nodes, sniff the cluster for you,
etc.  But it "external" to the cluster, similar to the REST clients.

The NodeClient, on the other hand, is actually a node within the cluster (but
does not hold data, and cannot become master).  Because it is a node, it knows
the entire cluster state -- where all the nodes reside, which shards live in which
nodes, etc.  This means it can execute APIs with one less network-hop.

There are uses-cases for both clients:

- TransportClient is ideal if you want to decouple your application from the
cluster.  For example, if your application quickly creates and destroys
connections to the cluster, a TransportClient is much "lighter" than a NodeClient,
since it is not part of a cluster.
+
Similarly, if you need to create thousands of connections, you don't want to
have thousands of NodeClients join the cluster.  The TC will be a better choice

- On the flipside, if you only need a few long-lived, persistent connection
objects to the cluster, a NodeClient can be a bit more efficient since it knows
the cluster layout.  But it ties your application into the cluster, so it may
pose problems from a firewall perspective, etc.




