=== Tuning disparate queries

The `multi_match` query in `bool` mode also understands per-field boosts, so
if we were most interested in the `name`, more interested in the `color` and
least interested in the `city`, we could give each field a different `boost`
as follows:

[source,js]
--------------------------------------------------
{
    "query": {
        "multi_match": {
            "query":       "red widget london",
            "fields":      [ "name^3", "color^2", "city" ],
            "use_dis_max": false
        }
    }
}
--------------------------------------------------

This helps to tune the query so that the results that we are most interested
in appear at the top of the list. But what about the other end of the results
list: that long tail of documents that match, but match poorly, such as
products which are in London, but are not widgets.

We could try to use the tools we talked about in <<match-precision>>: the
`"and"` operator or the `minimum_should_match` parameter:

[source,js]
--------------------------------------------------
{
    "query": {
        "multi_match": {
            "query":       "red widget london",
            "fields":      [ "name", "color", "city" ],
            "use_dis_max": false,
            "operator":    "and"
        }
    }
}
--------------------------------------------------

However, if you were to run this query against our one example document, you
would find that it does not match. Remember: the `operator` and
`minimum_should_match` parameters are passed down to each generated `match`
query, so the full generated query would look like this:

[source,js]
--------------------------------------------------
{
    "bool": {
        "should": [
            { "match": {
                "name": {
                    "query":       "red widget london",
                    "operator":    "and"
                }
            }},
            { "match": {
                "color": {
                    "query":       "red widget london",
                    "operator":    "and"
                }
            }},
            { "match": {
                "city": {
                    "query":       "red widget london",
                    "operator":    "and"
                }
            }}
        ]
    }
}
--------------------------------------------------

The `match` queries are added as `should` clauses, which means that only one
of them has to match. But the `"and"` operator is applied to every `match`
query, meaning that *all* of the words `"red"`, `"widget"` and `"london"`
must be present in the *same field*!

This clearly was not the intention. What we really wanted to achieve was to
require each word to be in *at least one* of the fields.
