==== Metadata: Document Identity
==== 메타데이터: 문서 아이덴티티

There are four metadata fields ((("metadata, document", "identity")))associated with document identity:

문서 아이덴티티와 연관된 네 개의 메타데이터 필드가 있다.((("metadata, document", "identity")))

`_id`::
   The string ID of the document

`_type`::
   The type name of the document

`_index`::
   The index where the document lives

`_uid`::
   The `_type` and `_id` concatenated together as `type#id`

`_id`::
   문서의 문자열 ID

`_type`::
   문서의 타입 이름

`_index`::
   문서가 포함된 인덱스

`_uid`::
   `_type`과 `_id`를 조합한 `type#id`값


By default, the `_uid` field is((("id field"))) stored (can be retrieved) and
indexed (searchable).  The `_type` field((("type field")))((("index field")))((("uid field")))
is indexed but not stored, and the `_id` and `_index` fields are neither indexed nor stored, meaning
they don't really exist.

기본적으로, `_uid` 필드((("id field")))는 저장 및 인덱스 된다 (조회할 수 있고 검색할 수 있다).
`_type` 필드((("type field")))((("index field")))((("uid field")))는 인덱스 되지만 저장되지 않으며,
`_id`와 `_index` 필드는 저장되거나 인덱스되지 않는데, 이것은 두 필드가 실제로 존재하지 않는다는 뜻이다.

In spite of this, you can query the `_id` field as though it were a real
field.  Elasticsearch uses the `_uid` field to derive the `_id`. Although you
can change the `index` and `store` settings for these fields, you almost
never need to do so.

그럼에도 불구하고, 마치 이 필드가 존재하는 것처럼 `_id` 필드에 대해 검색할 수 있다.
Elastisearch는 `_uid` 필드를 이용해 `_id` 필드를 파생시킨다.
이 필드들에 대한 `index` 및 `store` 설정을 변경할 수는 있지만, 그럴 필요는 거의 없을 것이다.

The `_id` field does have one setting that you may want to use: the `path`
setting tells((("id field", "path setting")))((("path setting, id field")))
Elasticsearch that it should extract the value for the
`_id` from a field within the document itself.

`_id` 필드에 대한 설정 중 유용한 것이 한 가지 있다.
`path` 설정을 이용하면((("id field", "path setting")))((("path setting, id field"))), 다음과 같이
Elasticsearch가 문서 내의 어떤 필드에서 `_id` 값을 추출할 지를 지정할 수 있다.

[source,js]
--------------------------------------------------
PUT /my_index
{
    "mappings": {
        "my_type": {
            "_id": {
                "path": "doc_id" <1>
            },
            "properties": {
                "doc_id": {
                    "type":   "string",
                    "index":  "not_analyzed"
                }
            }
        }
    }
}
--------------------------------------------------
// SENSE: 070_Index_Mgmt/33_ID_path.json
<1> Extract the doc `_id` from the `doc_id` field.
<1> 문서 `_id`를 `doc_id` 필드에서 추출한다.

Then, when you index a document:

그 후 다음과 같이 문서를 인덱스 하면,

[source,js]
--------------------------------------------------
POST /my_index/my_type
{
    "doc_id": "123"
}
--------------------------------------------------
// SENSE: 070_Index_Mgmt/33_ID_path.json


the `_id` value will be ((("doc_id field")))extracted from the `doc_id` field in the document
body:

`_id` 값은 ((("doc_id field"))) 다음과 같이 문서 바디의 `doc_id` 필드에서 추출한 값이 된다.

[source,js]
--------------------------------------------------
{
    "_index":   "my_index",
    "_type":    "my_type",
    "_id":      "123", <1>
    "_version": 1,
    "created":  true
}
--------------------------------------------------
<1> The `_id` has been extracted correctly.
<1> `_id`가 올바르게 추출되었다.


WARNING: While this is very convenient, be aware that it has a slight
performance impact on `bulk` requests (see <<bulk-format>>). The node handling
the request can no longer use the optimized bulk format to parse just
the metadata line in order to decide which shard should receive the request.
Instead, it has to parse the document body as well.

WARNING: 이것이 매우 편리하긴 하지만, `벌크` 요청(<<bulk-format>> 참조) 시 약간의 성능 저하를 가져온다는 것을 염두에 두도록 하자.
요청을 처리하는 노드는 메타데이터 라인만을 분석해 어떤 샤드가 요청을 받아야 할지를 결정하는
최적화된 벌크 형식을 더 이상 사용할 수 없고, 문서 바디까지 분석해야 한다.
