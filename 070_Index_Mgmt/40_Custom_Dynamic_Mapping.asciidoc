[[custom-dynamic-mapping]]
=== Customizing Dynamic Mapping
=== 동적 매핑 커스터마이징 하기

If you know that you are going to be adding new fields on the fly,
you probably want to leave dynamic mapping enabled.((("dynamic mapping", "custom")))((("mapping (types)", "dynamic", "custom")))  At times, though,
the dynamic mapping ``rules'' can be a bit blunt.  Fortunately, there
are settings that you can use to customize these rules to better
suit your data.

운영 중에 새로운 필드를 추가할 것이라는 것을 당신이 미리 알고 있다면, 동적 매핑 기능을 활성화해 두길 원할 것이다.((("dynamic mapping", "custom")))((("mapping (types)", "dynamic", "custom")))
하지만 때로는 동적 매핑 ``규칙''이 약간 포괄적일 수도 있다. 다행히도, 이 규칙을 당신의 데이터에 적합하게 커스터마이즈 할 수 있는 몇 가지 설정이 있다.


[[date-detection]]
==== date_detection

When Elasticsearch encounters a new string field, it checks to see if the
string contains a recognizable date, like `2014-01-01`.((("date_detection setting")))((("dynamic mapping", "custom", "date_detection setting"))) If it looks
like a date, the field is added as type `date`. Otherwise, it is
added as type `string`.

Elasticsearch는 새로운 문자열 필드가 나타나면, 그 문자열이 `2014-01-01`처럼 인식 가능한 날짜를 포함하고 있는지를 확인한다.((("date_detection setting")))((("dynamic mapping", "custom", "date_detection setting")))
만약 그 문자열이 날짜로 판단되면 `date` 타입 필드로 저장하고, 그렇지 않으면 `string` 타입 필드로 저장한다.

Sometimes this behavior can lead to problems.  Imagine that you index
a document like this:

때로 이런 동작이 문제를 일으킬 수도 있다. 다음과 같은 문서를 인덱싱한다고 가정해 보자.

[source,js]
--------------------------------------------------
{ "note": "2014-01-01" }
--------------------------------------------------


Assuming that this is the first time that the `note` field has been seen,
it will be added as a `date` field.  But what if the next document looks
like this:

`note` 필드가 처음 나타났다고 가정하면, 이것은 `date` 필드로 저장될 것이다.
하지만 다음 문서가 이런 형식이라면 어떻게 될까?

[source,js]
--------------------------------------------------
{ "note": "Logged out" }
--------------------------------------------------


This clearly isn't a date, but it is too late.  The field is already
a date field and so this ``malformed date'' will cause an exception to be
thrown.

이것은 명백히 날짜가 아니지만, 이미 늦어버렸다. 이 필드는 이미 날짜 필드로 설정되었기 때문에,
이 ``비정상 날짜'' 데이터는 예외를 발생시킬 것이다.

Date detection can be turned off by setting `date_detection` to `false`
on the ((("root object", "date_detection setting")))root object:

날짜 인식 기능은 다음과 같이 루트 객체((("root object", "date_detection setting")))에서 `date_detection`을 `false`로 설정하여 끌 수 있다.

[source,js]
--------------------------------------------------
PUT /my_index
{
    "mappings": {
        "my_type": {
            "date_detection": false
        }
    }
}
--------------------------------------------------


With this mapping in place, a string will always be a `string`.  If you need
a `date` field, you have to add it manually.

이 매핑이 설정되면, 문자열은 언제나 `string`으로 인식된다.
`date` 필드가 필요할 경우, 수동으로 추가해야 한다.

[NOTE]
====
Elasticsearch's idea of which strings look like dates can be altered
with the {ref}/dynamic-field-mapping.html#date-detection[`dynamic_date_formats` setting].
====

[NOTE]
====
Elasticsearch가 어떤 형태의 문자열을 날짜로 인식하는지에 대한 설정은 {ref}/dynamic-field-mapping.html#date-detection[`dynamic_date_formats` 설정]에서 변경할 수 있다.
====

[[dynamic-templates]]
==== dynamic_templates

With `dynamic_templates`, you can take complete control ((("dynamic_templates setting")))((("dynamic mapping", "custom", "dynamic_templates setting")))over the
mapping that is generated for newly detected fields. You
can even apply a different mapping depending on the field name
or datatype.

`dynamic_templates`((("dynamic_templates setting")))((("dynamic mapping", "custom", "dynamic_templates setting")))를 이용하면 새로 발견된 필드에 대한 매핑을 완전히 제어할 수 있다.
필드 이름이나 데이터 타입에 따라 서로 다른 매핑을 적용할 수도 있다.

Each template has a name, which ((("templates", "dynamic_templates setting")))you can use to describe what the template
does, a `mapping` to specify the mapping that should be applied, and
at least one parameter (such as `match`) to define which fields the template
should apply to.

각 템플릿은 다음 요소를 가지고 있다. 먼저, 이름은 템플릿이 어떤 역할을 하는지에 대한 설명의 용도로 사용할 수 있다.((("templates", "dynamic_templates setting"))) `mapping`은 적용되어야 하는 매핑을 지정할 용도로 사용하며, 이 템플릿이 어떤 필드들에 적용되어야 할 지를 정의할 때 사용하는 파라미터 (`match` 등의)를 최소한 하나 이상 가진다.


Templates are checked in order; the first template that matches is
applied. For instance, we could specify two templates for `string` fields:

템플릿은 순서대로 확인된다. 맨 처음 매치하는 템플릿이 적용된다. 예를 들어, `string` 필드에 대해 다음과 같이 두 개의 템플릿을 지정할 수 있다.

* `es`: Field names ending in `_es` should use the `spanish` analyzer.
* `en`: All others should use the `english` analyzer.
* `es`: `_es`로 끝나는 이름을 가진 필드는 `spanish` 분석기를 이용해야 한다.
* `en`: 다른 모든 필드는 `english` 분석기를 이용해야 한다.

We put the `es` template first, because it is more specific than the
catchall `en` template, which matches all string fields:

예제에서 `es` 템플릿을 먼저 배치했는데, 이는 다른 모든 문자열 필드에 매치하는 `en` 템플릿보다 더 제한적으로 적용되기 때문이다.

[source,js]
--------------------------------------------------
PUT /my_index
{
    "mappings": {
        "my_type": {
            "dynamic_templates": [
                { "es": {
                      "match":              "*_es", <1>
                      "match_mapping_type": "string",
                      "mapping": {
                          "type":           "string",
                          "analyzer":       "spanish"
                      }
                }},
                { "en": {
                      "match":              "*", <2>
                      "match_mapping_type": "string",
                      "mapping": {
                          "type":           "string",
                          "analyzer":       "english"
                      }
                }}
            ]
}}}
--------------------------------------------------
// SENSE: 070_Index_Mgmt/40_Custom_dynamic_mapping.json

<1> Match string fields whose name ends in `_es`.
<2> Match all other string fields.
<1> 이름이 `_es`로 끝나는 문자열 필드에 매치된다.
<2> 다른 모든 문자열 필드에 매치된다.

The `match_mapping_type`  allows ((("match_mapping_type setting")))you to apply the template only
to fields of the specified type, as detected by the standard dynamic
mapping rules, (for example `string` or `long`).

`match_mapping_type` 설정((("match_mapping_type setting")))을 이용하면 표준 동적 매핑 규칙에 의해 탐지되는 것 중, 특정한 타입(예를 들어 `string` 또는 `long`같은)의 필드에만 템플릿을 적용할 수 있다.

The `match` parameter matches just the field name, and the `path_match`
parameter((("path_map parameter"))) matches the full path to a field in an object, so
the pattern `address.*.name` would match a field like this:

`match` 파라미터는 필드 이름에 매치되는지만을 확인하는 데 반해, `path_match` 파라미터((("path_map parameter")))는 객체 내에서 필드에 대한 전체 경로가 매치하는지를 확인한다. 이 파라미터를 이용하면, `address.*.name` 패턴은 다음 예제의 필드에 매치하게 된다.

[source,js]
--------------------------------------------------
{
    "address": {
        "city": {
            "name": "New York"
        }
    }
}
--------------------------------------------------


The `unmatch` and `path_unmatch` patterns((("unmatch pattern")))((("path_unmap pattern"))) can be used to exclude fields
that would otherwise match.

`unmatch`와 `path_unmatch` 패턴((("unmatch pattern")))((("path_unmap pattern")))을 이용하면
지정된 패턴과 매치하지 않는 필드를 제외시킬 수 있다.

More configuration options can be found in the
{ref}/dynamic-mapping.html[dynamic mapping documentation].

더 많은 설정 옵션은 {ref}/dynamic-mapping.html[dynamic mapping documentation]에서 확인할 수 있다.
