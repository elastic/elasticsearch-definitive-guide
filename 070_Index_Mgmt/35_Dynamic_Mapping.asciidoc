[[dynamic-mapping]]
=== Dynamic Mapping
=== 동적 매핑 (Dynamic Mapping)

When Elasticsearch encounters a previously ((("mapping (types)", "dynamic")))((("dynamic mapping")))
unknown field in a document, it uses <<mapping-intro,_dynamic mapping_>> to determine
the datatype for the field and automatically adds the new field to the type mapping.

Elasticsearch가 문서에서 이전에 다루지 않았던 필드((("mapping (types)", "dynamic")))((("dynamic mapping")))를 만나게 되면, <<mapping-intro,_dynamic mapping_>>을 이용해 새로운 필드에 대한 데이터 타입을
결정하고, 타입 매핑에 새 필드를 추가한다.


Sometimes this is the desired behavior and sometimes it isn't. Perhaps
you don't know what fields will be added to your documents later,
but you want them to be indexed automatically.  Perhaps you just want
to ignore them.  Or--especially if you are using Elasticsearch as a
primary data store--perhaps you want unknown fields to throw an exception
to alert you to the problem.

이런 동작이 바람직할 때도 있고, 그렇지 않을 때도 있다.
당신이 나중에 문서에 어떤 필드가 추가될 지 알 수는 없지만, 자동으로 인덱스 되기를 원할 수도 있다.
아니면, 새로 추가되는 필드를 그냥 무시하기를 원할 수도 있다. 또는, (특히 Elasticsearch를 주 데이터 저장소로 사용하는 중이라면) 알려지지 않은 필드가 나타나면 예외를 발생시켜 문제에 대한 경고를 해 주기를 원할 수도 있다.

Fortunately, you can control this behavior((("dynamic setting"))) with the `dynamic` setting,
which accepts the following options:

다행히도, `dynamic` 설정을 이용해 이 동작((("dynamic setting")))을 제어할 수 있다.
설정할 수 있는 값은 다음과 같다.

`true`::
   Add new fields dynamically--the default

`false`::
   Ignore new fields

`strict`::
   Throw an exception if an unknown field is encountered

`true`::
   새로운 필드를 자동으로 추가한다. (기본값)

`false`::
   새로운 필드를 무시한다.

`strict`::
   새로운 필드가 나타나면 예외를 발생시킨다.


The `dynamic` setting may be applied to the root object or to any field
of type `object`.  You could set `dynamic` to `strict` by default,
but enable it just for a specific inner object:

`dynamic` 설정은 루트 객체 또는 `object` 타입의 어떤 필드에나 적용될 수 있다.
다음과 같이 `dynamic`의 기본 설정값을 `strict`로 설정하되, 특정한 내부 객체에 대해서만 활성화 할 수도 있다.
(dynamic 설정 값을 true로 적용할 수도 있다. ?)

[source,js]
--------------------------------------------------
PUT /my_index
{
    "mappings": {
        "my_type": {
            "dynamic":      "strict", <1>
            "properties": {
                "title":  { "type": "string"},
                "stash":  {
                    "type":     "object",
                    "dynamic":  true <2>
                }
            }
        }
    }
}
--------------------------------------------------
// SENSE: 070_Index_Mgmt/35_Dynamic_mapping.json
<1> The `my_type` object will throw an exception if an unknown field is encountered.
<2> The `stash` object will create new fields dynamically.
<1> `my_type` 객체는 알려지지 않은 필드가 나타나면 예외를 발생시킨다.
<2> `stash` 객체는 새로운 필드를 동적으로 생성할 것이다.


With this mapping, you can add new searchable fields into the `stash` object:

이 매핑을 이용하면, 다음과 같이 `stash` 객체에 새로운 검색 가능한 필드를 추가할 수 있다.

[source,js]
--------------------------------------------------
PUT /my_index/my_type/1
{
    "title":   "This doc adds a new field",
    "stash": { "new_field": "Success!" }
}
--------------------------------------------------
// SENSE: 070_Index_Mgmt/35_Dynamic_mapping.json


But trying to do the same at the top level will fail:

하지만, 최상위 객체에서 동일한 상황이 벌어지면 예외가 발생한다.

[source,js]
--------------------------------------------------
PUT /my_index/my_type/1
{
    "title":     "This throws a StrictDynamicMappingException",
    "new_field": "Fail!"
}
--------------------------------------------------
// SENSE: 070_Index_Mgmt/35_Dynamic_mapping.json


NOTE: Setting `dynamic` to `false` doesn't alter the contents of the `_source`
field at all. The `_source` will still contain the whole JSON document that
you indexed.  However, any unknown fields will not be added to the mapping and
will not be searchable.

NOTE: `dynamic` 설정을 `false`로 바꾸어도 `_source` 필드의 내용은 바뀌지 않는다. `_source`는 여전히 인덱스 한 JSON 문서 전체를 포함하고 있을 것이다. 하지만, 알려지지 않은 필드는 매핑에 추가되지 않을 것이고, 검색할 수도 없을 것이다.
